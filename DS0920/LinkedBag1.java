package DS0920;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. * * @author Frank M. Carrano * @version 3.0 */public class LinkedBag1<T> implements BagInterface<T> {    private Node firstNode;       // reference to first node    private int numberOfEntries;    public LinkedBag1() {        firstNode = null;        numberOfEntries = 0;    } // end default constructor    /**     * Sees whether this bag is empty.     *     * @return true if the bag is empty, or false if not     */        public boolean isEmpty() {        return numberOfEntries == 0;        //return firstNode == null;    } // end isEmpty        /**     * Gets the number of entries currently in this bag.     *     * @return the integer number of entries currently in the bag     */        public int getCurrentSize() {        return numberOfEntries;    } // end getCurrentSize        /**     * Adds a new entry to this bag.     *     * @param newEntry the object to be added as a new entry     * @return true if the addition is successful, or false if not     */    public boolean add(T newEntry) // OutOfMemoryError possible    {        // add to beginning of chain:        Node newNode = new Node(newEntry);        newNode.next = firstNode; // make new node reference rest of chain (firstNode is null if chain is empty)                firstNode = newNode;      // new node is at beginning of chain        numberOfEntries++;        return true;    } // end add    /**     * Sees whether this bag is full.     *     * @return false     */        public boolean isFull() {        return false;    } // end isFull        /**     * Removes one unspecified entry from this bag, if possible.     *     * @return either the removed entry, if the removal was successful, or null     */    public T remove() {        T result = null;        if (this.firstNode != null) {            result = firstNode.data;            this.firstNode = firstNode.next;            this.numberOfEntries--;            return result;        } else {            return null;        }    } // end remove            /**     * Removes one occurrence of a given entry from this bag.     *     * @param anEntry the entry to be removed     * @return true if the removal was successful, or false otherwise     */    /*    public boolean remove(T anEntry) {        return false; // STUB    } // end remove    */    /**     * Removes all entries from this bag.     */    public void clear() {        // STUB    } // end clear    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry the entry to be counted     * @return the number of times anEntry appears in the bag     */        public int getFrequencyOf(T anEntry) {        int frequency = 0;        int counter = 0;        Node currentNode = firstNode;        while ((counter < this.numberOfEntries) && (currentNode != null)) {            if (anEntry.equals(currentNode.data)) {                frequency++;            }            currentNode = currentNode.next;        }        return frequency;    } // end getFrequencyOf        /**     * Tests whether this bag contains a given entry.     *     * @param anEntry the entry to locate     * @return true if the bag contains anEntry, or false otherwise     */        public boolean contains(T anEntry) {        //int frequency = 0;        int counter = 0;        Node currentNode = firstNode;        while ((counter < this.numberOfEntries) && (currentNode != null)) {            if (anEntry.equals(currentNode.data)) {                //frequency++;                return true;            }            currentNode = currentNode.next;        }        //return frequency;        return false;    } // end contains        /**     * Retrieves all entries that are in this bag.     *     * @return a newly allocated array of all the entries in the bag     */        public T[] toArray() {        // the cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] result = (T[]) new Object[numberOfEntries]; // unchecked cast        int index = 0;        Node currentNode = firstNode;        while ((index < numberOfEntries) && (currentNode != null)) {            result[index] = currentNode.data;            index++;            currentNode = currentNode.next;        } // end while        return result;    } // end toArray    private class Node {        private T data; // entry in bag        private Node next; // link to next node        private Node(T dataPortion) {            this(dataPortion, null);        } // end constructor        private Node(T dataPortion, Node nextNode) {            data = dataPortion;            next = nextNode;        } // end constructor    } // end Node	@Override	public boolean remove(T anEntry) {		int counter=0;		boolean isFound=false;		Node currentNode = firstNode;		Node tempNode=firstNode;				while((counter<numberOfEntries)&&(currentNode != null)) {			if(anEntry.equals(tempNode)) {				isFound=true;				while(currentNode.next==tempNode) {					currentNode=currentNode.next;				}				currentNode.next=tempNode.next;				tempNode=tempNode.next;//같은 Node를 모두 지우기 때문에 tempNode를 next해줌			} else {				tempNode=tempNode.next;			}		}		return isFound;	}} // end LinkedBag1