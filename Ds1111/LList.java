package Ds1111;/**   A linked implementation of the ADT list.   @author Frank M. Carrano   @version 2.0*/public class LList<T> implements ListInterface<T>{	private Node<T> firstNode; // reference to first node	private int  numberOfEntries; 	public LList()	{		clear();	} // end default constructor		public final void clear() // note the final method	{		firstNode = null;		numberOfEntries = 0;	} // end clear	/** Sees whether this bag is empty.		 @return true if the bag is empty, or false if not */	public boolean isEmpty()    {            return this.numberOfEntries == 0;    }	public void add(T newEntry)	{            Node<T> newNode = new Node<T>(newEntry);                        			if(isEmpty()) {				firstNode = newNode;			} else {			//Node<T> newNode = new Node(newEntry);			Node lastNode = getNodeAt(numberOfEntries);            lastNode.setNextNode(newNode);			}            numberOfEntries++;	}	public boolean add(int newPosition, T newEntry)	{		Node preNode = null;		Node targetNode = null;		Node<T> newNode = new Node<T>(newEntry);		if (newPosition > 1)		{			preNode = getNodeAt(newPosition-1);			targetNode = preNode.getNextNode();						preNode.setNextNode(newNode);			newNode.setNextNode(targetNode);		} else		{			//newPosition == 1			preNode = null;			targetNode = firstNode;			newNode.setNextNode(targetNode);			firstNode = newNode;		}		return true;	}	public T remove(int givenPosition)	{		T result = null;		if ( givenPosition < 1 || givenPosition > numberOfEntries)		{			return null;		}				if (givenPosition > 1)		{			Node<T> nodeBefore = getNodeAt(givenPosition-1);			Node<T> nodeToRemove = nodeBefore.getNextNode();			Node<T> nodeAfter = nodeToRemove.getNextNode();			nodeBefore.setNextNode(nodeAfter);			result = nodeToRemove.getData();		} else		{			//givenPosition == 1			result = firstNode.getData();			firstNode = firstNode.getNextNode();		}		numberOfEntries--;		return result;	}	public T getEntry(int givenPosition)	{		T result = null;		if ( (givenPosition >= 1) && (givenPosition <=numberOfEntries))		{			result = getNodeAt(givenPosition).getData();		}		return result;	}	public int getLength()	{		return numberOfEntries;	}  /*  < Implementations of the public methods add, remove, replace, getEntry, contains,       getLength, isEmpty, and toArray go here. >  . . . */  	// Returns a reference to the node at a given position.   // Precondition: List is not empty;   //               1 <= givenPosition <= numberOfEntries		private Node<T> getNodeAt(int givenPosition)	{		assert !isEmpty() && (1 <= givenPosition) && (givenPosition <= numberOfEntries);		Node currentNode = firstNode;		      // traverse the list to locate the desired node		for (int counter = 1; counter < givenPosition; counter++)			currentNode = currentNode.getNextNode();				assert currentNode != null;      		return currentNode;	} // end getNodeAt  } // end LList