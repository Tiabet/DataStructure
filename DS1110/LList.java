package DS1110;/** * A linked implementation of the ADT list. * * @author Frank M. Carrano * @version 2.0 */public class LList<T> implements ListInterface<T> {	private Node<T> firstNode; // reference to first node	private int numberOfEntries;	public LList() {		clear();	} // end default constructor	public final void clear() // note the final method	{		firstNode = null;		numberOfEntries = 0;	} // end clear	public boolean isEmpty() {		return (firstNode == null);	}	public T remove(int givenPosition) {		T result = null;		if (givenPosition < 1 || givenPosition > numberOfEntries) {			return null;		}		if (givenPosition > 1) {			Node<T> nodeBefore = getNodeAt(givenPosition - 1);			Node<T> nodeToRemove = nodeBefore.getNextNode();			Node<T> nodeAfter = nodeToRemove.getNextNode();			nodeBefore.setNextNode(nodeAfter);			result = nodeToRemove.getData();			//삭제하고자 하는 노드의 전 노드, 후 노드를 서로 연결시켜줌		} else {			// givenPosition == 1			result = firstNode.getData();			firstNode = firstNode.getNextNode();			//firstNode를 뒤 노드로 바꿔주는 것만으로 삭제 과정 가능		}		numberOfEntries--;		return result;	}	public boolean add(int newPosition, T newEntry) {		Node newnode = new Node(newEntry);		Node beforeNode;		Node targetNode;		if (newPosition > 1) {			beforeNode = this.getNodeAt(newPosition - 1);			targetNode = beforeNode.getNextNode();			// Node targetNode = this.getNodeAt(newPosition);			beforeNode.setNextNode(newnode);			newnode.setNextNode(targetNode);			// newnode가 넣으려는 node, 넣으려는 자리에 있는 노드(targetNode)와			// 그 앞에 있는 노드(BeforeNode)를 찾아서 저장시켜주고 newnode를 기준으로 연결시켜줌		} else {			// assert newPosition == 1			beforeNode = null;			targetNode = firstNode;			newnode.setNextNode(targetNode);			firstNode = newnode;		}		numberOfEntries++;		return true;	}	public boolean contains(T anEntry) {		Node node = this.firstNode;		if (this.isEmpty()) {			return false;		} else {			boolean isFound = false;			while (node != null && (isFound = node.getData().equals(anEntry)) == false) {				node = node.getNextNode();			}			return isFound;		}	}	/*	 * < Implementations of the public methods add, remove, replace, getEntry,	 * contains, getLength, isEmpty, and toArray go here. > . . .	 */	// Returns a reference to the node at a given position.	// Precondition: List is not empty;	// 1 <= givenPosition <= numberOfEntries	private Node<T> getNodeAt(int givenPosition) {		assert !isEmpty() && (1 <= givenPosition) && (givenPosition <= numberOfEntries);		Node currentNode = firstNode;		// traverse the list to locate the desired node		for (int counter = 1; counter < givenPosition; counter++) {			currentNode = currentNode.getNextNode();		}		assert currentNode != null;		return currentNode; //해당 포지션에 해당하는 노드를 반환	} // end getNodeAt	@Override	public void add(T newEntry) {		Node<T> newNode = new Node<T>(newEntry);		if (isEmpty()) {			firstNode = newNode;		} else {			// Node<T> newNode = new Node(newEntry);			Node lastNode = getNodeAt(numberOfEntries);//getNodeAt이 있으면 이런 걸 편하게 할 수 있음			lastNode.setNextNode(newNode);		}		numberOfEntries++;	}	@Override	public T getEntry(int givenPosition) {		T result = null;		if ((givenPosition >= 1) && (givenPosition <= numberOfEntries)) {			result = getNodeAt(givenPosition).getData();		}		return result; //그 위치의 노드의 데이터를 반환, getNodeAt하고는 약간 다름	}	@Override	public int getLength() {		return this.numberOfEntries;	}} // end LList